正则表达式：Regular Expression

	字符集
		        [0-9] 一位数字
		        [a-z] 一位小写字母 
			[A-Z] 一位大写字母
			[A-Za-z] 一位字母，大小写都行
			[0-9A-Za-z] 一位字母或数字
			[\u4e00-\u9fa5] 一位汉字		
   
	 预定义字符集  
			 \d 1位数字
			 \w 1位字母，数字或_
			 \s 1位空字符：空格，tab,...
			 .  一切字符
			 \b 单词边界
	 
	 量词：
	  有明确数量：
			{n,m} 最少n个 最多m个
			{n,}  至少n个 最多无限
			{n}   必须n个 不能多也不能少
		
	  没有明确数量：
			?    可有可无，最多一个
			*    可有可无，多了不限
			+    至少一个，多了不限		 
	 强调：量词默认值修饰相邻的前一个字符集	 

	 选择和分组
	   1.选择：等效于程序中的或
	     如何：规则1|规则2
		 
	   2.分组：将多个子规则用()，包裹为一组
	     如何：(规则1...)	 
		 	 
	 匹配特殊位置：
			 开头 ^
			 结尾 $
			 单词边界 \b	“边界”包含：空格，开头，结尾，标点符号

	  专门用于匹配一个独立的单词 
			\b单词\b	 

	  只匹配开头的空字符 ^\s+
	  只匹配结尾的空字符 \s+$
	  既匹配开头又匹配结尾 ^\s+|\s+$

		 
正则表达式的问题：
   如果验证时，只要部分匹配，就会返回true!
  解决方法：只要验证，必须同时前加^后加$，表示必须从头到尾完整匹配。

补充 ：
  分组编号：
  如何使用：
	var str="19940819";
	str2=str.replace(/(\d{4})(\d{2})(\d{2})/,"$1年$2月$3日");

	$1代表第1个()中的编号 后面代表要加入的内容
	$2代表第2个()中的编号 后面代表要加入的内容
  
	注意：
		$1在正则表达式//中用\1表示
	ex：
		找到str中 包含与首位相同字母的单词 放入arr中：
		var arr="abc acd ddc bxd bxz del acoo ccc dzd";
		    arr=arr.match(/\b([a-z])([a-z]*\1|\1[a-z]*)\b/g);
		用\1 表示()$1 中的值


ex：  
	车牌号：[\u4e00-\u9fa5][A-Z] [A-Z0-9][A-Z0-9][A-Z0-9][A-Z0-9][A-Z0-9]
		除了：
			如：
			[^a-z] 一位不是小写字母的字符
			<a[^>]+>  注：匹配范围太大！
	
	身份证号：
			 15位数字：\d{15}
			 2位数字： \d{2}
			 1位数字或X,x: [0-9Xx]
			 后三位整体可有可无，最多一次！
			 
			 230523199401011234
			\d{15}(\d{2}[0-9Xx])?
					 
	 手机号：
		 +86或0086 至少一个空字符  可有可无，最多1次
		 1
		 必须在3,4,5,6,7,8之间选一个
		 9位数字

		 ((\+86|0086)\s+)?1[345678]\d{9}
		 
	 屏蔽"微信":
		 (微|w(ei)?)\s*(信|x(in)?)