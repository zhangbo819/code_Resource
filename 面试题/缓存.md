# 浏览器缓存策略

## 大纲

1. [强缓存](#强缓存)
   1. Expire
   2. Cache-Control 的值为 “public, max-age=xxx”
2. [协商缓存](#协商缓存)
   1. Etag/If-None-Match
   2. Last-Modifed/If-Modified-Since

## 强缓存

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程

强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。
2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用**协商缓存**。
3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

### Expires

Expires 的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。

- 不过 Expires 是 **HTTP 1.0** 的东西，现在默认浏览器均默认使用 HTTP 1.1，所以它的作用基本忽略。
- 另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。 
- 所以 HTTP 1.1 的版本，使用 Cache-Control 替代。


### Cache-Control

常见的取值有 private、public、no-cache、max-age、no-store;

1. public: 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容;
2. private: 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器;
3. no-cache: 在发布缓存副本之前，**强制**要求缓存把请求提交给原始服务器进行**验证**(协商缓存验证);
4. no-store: 缓存不应存储有关客户端请求或服务器响应的任何内容，即不**使用任何缓存**;
5. max-age: 缓存保质期。



### Expires 和 Cache-Control 的关系

相同点

1. 都是强制缓存

不同点

1. Expires 是 **http 1.0** 规定的，而 Cache-Control 是 **http 1.1** 规定的
2. Expires 的过期时间采用的是**绝对时间**，容易造成差错； 而 Cache-Control 的过期时间采用的是**相对时间**
3. 两者可以同时存在于一次请求中，但是不会同时在一次请求中起作用。 在 HTTP 1.0 的环境下，Cache-Control 不起作用，Expires 起作用； 在 HTTP 1.1 的环境之下， Expires 不起作用，而 **Cache-Control 起作用**。当前一般都是 HTTP 1.1 的情况，所以 Expires 是作为一种向下兼容的形式而存在的；
4. Cache-Control 的选择更多，功能更为强大，**推荐使用**。 Expires 作为强缓存，功能单一，不推荐使用；


## 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

1. 协商缓存生效，返回304
2. 协商缓存失效，返回200和请求结果结果

向服务器发送请求，服务器会根据这个请求的 request header 里的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源，如果没命中则返回 200 状态码和新资源

- Last-Modifed / If-Modified-Since 的时间精度是秒，而 Etag 可以更精确。
- Etag 优先级是高于 Last-Modifed 的，所以服务器会优先验证 Etag
- Last-Modifed / If-Modified-Since 是 http 1.0 的头字段

### Etag

Etag 是 属于 HTTP 1.1 属性，它是由服务器（Apache 或者其他工具）生成返回给前端，用来帮助服务器控制 Web 端的缓存验证。
Apache 中，ETag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行 Hash 后得到的。

Etag/If-None-Match 优先级高于 Last-Modifed/If-Modified-Since

### If-None-Match

再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比

- 不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。
- 相同，说明资源无修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304.

### Last-Modified

服务器在响应请求时，会告诉浏览器资源的最后修改时间。

### If-Modified-Since

浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。

- 被修改：那么开始传输响应一个整体，服务器返回：200 OK
- 没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified

### Etag 与 Last-Modified 对比

1. 在精确度上，Etag 优于 Last-Modified。Last-Modified 精确到 s，如果 1s 内，资源多次改变，Etag 是可以判断出来并返回最新的资源;
2. 在性能上，Last-Modified 优于 Etag，因为 Last-Modified 只需要记录时间，而 Etag 需要服务器重新生成 hash 值，所以性能上略差;
3. 在优先级上，Etag 优于 Last-Modified，Etag 和 Last-Modified 可同时存在。本地缓存时间到期后，浏览器向服务端发送请求报文，其中 Request Header 中包含 If-none-match 和 Last-Modified-Since（与服务端 Etag 和 Last-Modified 对比，Etag 优先级高），用以验证本地缓存数据验证是否与服务端保持一致。在服务器端会优先判断 Etag。如果相同，返回 304；如果不同，就继续比较 Last-Modified，然后决定是否返回新的资源。若服务端验证本地缓存与服务端一致，返回 304，浏览器加载本地缓存；否则，服务器返回请求的资源，同时给出新的 Etag 以及 Last-Modified 时间;   s


## 强制缓存和协商缓存的区别

强制缓存和协商缓存命中缓存资源后，都是从本地读取资源。如果强制缓存生效，则不需要再向服务器发出请求；而协商缓存，不管是否使用缓存，必须向服务器发送一个请求来协商。

两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。如果强制缓存规则不生效，则需要进行协商缓存判断。


## 参考链接

[外链 - 浏览器缓存知识梳理](https://juejin.cn/post/6947936223126093861)
[外链 - 面试题 -- 说下浏览器缓存策略](https://juejin.cn/post/7068583507844399134)